<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【图像处理】LBP特征描述算子 | 私人海域</title><meta name="description" content="LBP特征描述算子 局部二值模型（Location Binary Pattern，LBP）是一种图像纹理的描述算子，所以我们首先要知道什么是图像的纹理特征，进而了解LBP算子的基本原理及其应用拓展。由于在原始的LBP提出后，研究人员还提出了各种改进方法，我们都将一一做介绍。最后使用opencv进行人脸识别。  图像纹理特征 纹理是一种反映图像中同质现象的视觉特征，它体现了物体表面的具有重复性和周"><meta name="keywords" content="中等"><meta name="author" content="Sonata,sonatau@163.com"><meta name="copyright" content="Sonata"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjtdrp4tj30rs0rsjwe.jpg"><link rel="canonical" href="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91LBP%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="【图像处理】LBP特征描述算子"><meta property="og:url" content="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91LBP%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><meta property="og:site_name" content="私人海域"><meta property="og:description" content="LBP特征描述算子 局部二值模型（Location Binary Pattern，LBP）是一种图像纹理的描述算子，所以我们首先要知道什么是图像的纹理特征，进而了解LBP算子的基本原理及其应用拓展。由于在原始的LBP提出后，研究人员还提出了各种改进方法，我们都将一一做介绍。最后使用opencv进行人脸识别。  图像纹理特征 纹理是一种反映图像中同质现象的视觉特征，它体现了物体表面的具有重复性和周"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bffpptgj318g0o20xd.jpg"><meta property="article:published_time" content="2020-08-24T15:23:14.000Z"><meta property="article:modified_time" content="2020-08-24T15:25:41.653Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-24 23:25:41'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.2"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjow3dndj30jg0jgdgq.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#lbp%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90"><span class="toc-number">1.</span> <span class="toc-text"> LBP特征描述算子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text"> 图像纹理特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AClbp"><span class="toc-number">1.2.</span> <span class="toc-text"> 基本LBP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 主要步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%86%E5%BD%A2%E9%82%BB%E5%9F%9F%E7%9A%84lbp%E7%AE%97%E5%AD%90"><span class="toc-number">1.3.</span> <span class="toc-text"> 圆形邻域的LBP算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 概念理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 计算方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%8C%96%E7%9A%84lbp%E7%AE%97%E5%AD%90"><span class="toc-number">1.4.</span> <span class="toc-text"> 统一化的LBP算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 理论基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%8C%96%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 统一化的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E7%AE%B1%E4%B8%AA%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 收集箱个数计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#opencv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.</span> <span class="toc-text"> openCV实现人脸检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 读取图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E7%BA%A7%E8%81%94%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 加载级联文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 人脸检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.4.</span> <span class="toc-text"> 处理脏数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.6.</span> <span class="toc-text"> C++实现人脸检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8Blbp%E7%AE%97%E5%AD%90"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 原始LBP算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%86%E5%BD%A2lbp%E7%AE%97%E5%AD%90"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 圆形LBP算子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text"> 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.8.</span> <span class="toc-text"> 参考资料</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bffpptgj318g0o20xd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">私人海域</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【图像处理】LBP特征描述算子</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-24T15:23:14.000Z" title="发表于 2020-08-24 23:23:14">2020-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-24T15:25:41.653Z" title="更新于 2020-08-24 23:25:41">2020-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/openCV/">openCV</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="lbp特征描述算子"><a class="markdownIt-Anchor" href="#lbp特征描述算子"></a> LBP特征描述算子</h2>
<p>局部二值模型（Location Binary Pattern，LBP）是一种图像纹理的描述算子，所以我们首先要知道什么是图像的纹理特征，进而了解LBP算子的基本原理及其应用拓展。由于在原始的LBP提出后，研究人员还提出了各种改进方法，我们都将一一做介绍。最后使用opencv进行人脸识别。</p>
<h3 id="图像纹理特征"><a class="markdownIt-Anchor" href="#图像纹理特征"></a> 图像纹理特征</h3>
<p>纹理是一种反映图像中同质现象的视觉特征，它体现了物体表面的具有重复性和周期性变化的表面结构组织排列属性。物体的纹理可以在其亮度和颜色上有所体现，而且几乎所有图像都包含了纹理信息，它可以表现这个物体的表面信息。有时候，它还能表达自身与外界环境的关系。</p>
<p>其中，纹理有三大特点，它们分别是：</p>
<ol>
<li>重复性：图像可以看作是某种局部元素在全局区域的不断重复出现。</li>
<li>周期性：图像中的元素并非随机出现，而是按照一定的周期性重复出现。</li>
<li>同质性：重复出现的元素在结构和尺寸上大致相同。</li>
</ol>
<p>由上可见，纹理是某种局部序列性不断重复、非随机排列、在结构和尺寸上大致相同的统一体。纹理图像示例如图5-2所示，图中第一行表示人工纹理，第二行是自然纹理。</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626164302970-1448035010.png"  style = "width: 40% ;">
<p>纹理特征只是对物体表面特性进行描述，并不能反映物体的本质属性，即图像高层语义信息。</p>
<h3 id="基本lbp"><a class="markdownIt-Anchor" href="#基本lbp"></a> 基本LBP</h3>
<p>####概念理解</p>
<p>LBP算子的基本思想是将中心像素的灰度值作为一个阈值，将其邻域内的像素点灰度值进行比较，从而得到二进制编码表示，来表示局部纹理特征。</p>
<blockquote>
<p>邻域的类型可分为四邻域、D邻域、八邻域，四邻域：该像素点的上下左右四个位置；</p>
<p>D领域：该像素点斜对角线上的四个相邻位置。</p>
<p>八邻域：四邻域与D邻域的并集。</p>
<p>基本的LBP算子考虑的是像素的八邻域。</p>
</blockquote>
<p>LBP表示方法有一个较为明显的特点，它不容易收到图像整体会读线性变化的影响。也就是说，当图像由于光线的影响使得整体灰度值发生线性均匀变化时，其LBP特征编码是不变的。换句话说，它并不在意整体的灰度变化，而是关注像素之间的相对灰度改变。</p>
<p>例如，在某些情况下，阳光照射强度更低，导致拍摄图像的整体亮度降低，但是实际上每个像素之间的差值仍然是固定的。那么在这种情况下，在图片亮度对LBP特征编码无影响。</p>
<h4 id="主要步骤"><a class="markdownIt-Anchor" href="#主要步骤"></a> 主要步骤</h4>
<p>使用一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的矩形形，处理待判断像素点及其邻域之间的关系。</p>
<p><strong>1. 二值化过程</strong></p>
<p>将像素点A的值与其八邻域处的像素点逐一比较：</p>
<ol>
<li>如果A的像素值大于其邻近点的像素值，则得到0。</li>
<li>如果A的像素值小于其邻近点的像素值，则得到1。</li>
</ol>
<p>此过程以中心像素的灰度值为阈值，与邻域的8个灰度值进行比较。</p>
<p>最后，根据顺时针方向，将像素点A与周围8个像素点比较所得到的0、1值连接起来，得到一个8位的二进制序列，然后将该二进制序列转换为十进制数字作为点A的LBP值。</p>
<p>如下图LBP原理示意图所示，在左侧<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>的区域中，中心点的像素为76，并设置它为此次的阈值。然后现在我们对该中心点的8邻域做进一步的处理。</p>
<ol>
<li>将中心点周围的8个位置中灰度值大于76的像素点处理为1。例如，其邻域中像素值为128、251、99、213的点，都被处理为1，填入对应的像素点位置上。</li>
<li>将中心点周围的8个位置中灰度值值小于76的像素点处理为0。例如，其邻域中像素值为36、9、11、48的点，都被处理为0，填入对应的像素点位置上。</li>
<li>最后得到的二值结果如右图所示。</li>
</ol>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626164329211-351623235.png"  style = "width: 40%; ">
<p><strong>2. 中心点处理</strong></p>
<p>完成上述的二值化过程之后，例如从像素点的正上方开始将得到的二值结果进行序列化，所以在上述例子中，二进制序列结果为“01011001”。</p>
<p>最后再将该二进制序列结果转换为对应的十进制数“89”，作为当前中心点的像素值，如下图所示。</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626164439705-1360564195.png" style = "width: 40%;">
<p><strong>3. 整合处理</strong></p>
<p>上述过程仅仅是对一个像素点的处理过程，结果是一个LBP“编码”。所以对于某幅图像而言，需要进行逐行扫描完成每个像素点数值的更新。我们将采用<strong>分块</strong>的形式进行编码。其编码过程如下：</p>
<p>假设此时有一幅100*100大小的图像。</p>
<ol>
<li>在初始化时，将该图划分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>×</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">10 \times 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>  个Block，其中每个Block的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>×</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">10 \times 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>。</li>
<li>对每个Block的像素点提取其LBP特征，并建立一个计算某个“数字”出现的频率统计直方图。</li>
<li>结束时，将生成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>×</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">10 \times 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 个统计直方图，选择性地对直方图进行规范化处理。</li>
<li>连接所有小块的（规范化的）直方图，整合后构成了整个窗口的特征向量，用来描述这幅图片。</li>
<li>得到特征向量之后，就可以使用各类算法对该图像进行特定的处理了。</li>
</ol>
<h3 id="圆形邻域的lbp算子"><a class="markdownIt-Anchor" href="#圆形邻域的lbp算子"></a> 圆形邻域的LBP算子</h3>
<h4 id="概念理解"><a class="markdownIt-Anchor" href="#概念理解"></a> 概念理解</h4>
<p>基本LBP算子可以被进一步推广到使用不同大小和形状的邻域。采用圆形的邻域并结合双线性插值运算使得我们可以获得任意半径和任意数目的邻域像素点。该圆形邻域可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>B</mi><msubsup><mi>P</mi><mi>P</mi><mi>R</mi></msubsup></mrow><annotation encoding="application/x-tex">LBP^R_P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1166619999999998em;vertical-align:-0.275331em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.424669em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>表示，其中P表示圆形邻域内参与运算的像素点个数，R表示邻域的半径。</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626164547688-323761618.png" style = "width: 30%;">
<h4 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h4>
<p>假设此时给出了一个半径为2的8邻域像素的圆形邻域，图中每个方格对应一个像素。</p>
<ol>
<li>处在方格中心的邻域点（左、上、右、下4个黑点）：以该点所在方格的像素值作为它的值</li>
<li>不在方格中心的邻域点（斜45°方向的4个黑点）：线性插值法确定其值。</li>
</ol>
<p>如下图所示，若现在我们想计算左上角空心点的值，此时它并不在任何像素点内：</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626165537864-895909608.png" style="width: 40%">
<p>可以发现，在空心点的上方，距离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>−</mo><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">2- \sqrt2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span>处，有一个十叉点1，下方还有一个十叉点2。所以我们应首先分别计算这两个十叉点1和2的水平插值。</p>
<p>其中点1的值根据与之处于同一行的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(i-2, j-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">I(i-2, j-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>的线形插值得到。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>−</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">value(1) = I(i-2, j-2) + (2 - \sqrt2) \times (I(i-2, j-1) - I(i-2, j-2))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.206095em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.956095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.916095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08390500000000001em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>同理计算出点2的值如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>−</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>I</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">value(2) = I(i-1, j-2) + (2 - \sqrt2) \times (I(i-1, j-1) - I(i-1, j-2))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.206095em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.956095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.916095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08390500000000001em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>再计算出点1和点2竖直的线性插值。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>=</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>2</mn><mo>−</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">value = value(1) + (2 - \sqrt2) \times (value(2) - value(1))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.206095em;vertical-align:-0.25em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.956095em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.916095em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08390500000000001em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>如此，计算出各邻域像素点的灰度值之后，仍然使用基础LBP算子的方法，得到二进制序列后转换为十进制数等操作。</p>
<p>###旋转不变的LBP算子</p>
<p>根据上述介绍发现，像素点的二进制序列将由于图像的旋转而改变，因此它并不具有旋转不变性。</p>
<p>那么，应该如何解决这样的情况呢？</p>
<p>此后，Maenpaa等人又将 LBP 算子进行了扩展，提出了具有旋转不变性的 LBP 算子，即不断旋转圆形邻域得到一系列初始定义的 LBP 值，取其<strong>最小值</strong>作为该邻域的 LBP 值。</p>
<p>如下图所示，黑点代表0，白点代表1，假设初始的灰度值为255。经过7次旋转，得到7个不同的二进制序列，并分别转换为相应的十进制数，最后取到最小值“15”为最终中心点的LBP值，且序列为“00001111”。</p>
<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/20180130113806268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGVsaTIwMDQ4MjEyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom: 67%;" />
<h3 id="统一化的lbp算子"><a class="markdownIt-Anchor" href="#统一化的lbp算子"></a> 统一化的LBP算子</h3>
<h4 id="理论基础"><a class="markdownIt-Anchor" href="#理论基础"></a> 理论基础</h4>
<p>由于LBP直方图大多都是针对图像中的各个分区分别计算的，对于一个普通大小的分块区域，标准LBP算子得到的二进模式数目（LBP直方图收集箱数目）较多，而实际的位于该分块区域中的像素数目却相对较少，这将会得到一个过于稀疏的直方图，使得该直方图失去统计的意义。</p>
<p>例如，在5×5邻域内对20个像素点进行采样，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn><mo>=</mo><mn>1048576</mn></mrow><annotation encoding="application/x-tex">2^20 = 1048576</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">4</span><span class="mord">8</span><span class="mord">5</span><span class="mord">7</span><span class="mord">6</span></span></span></span>种二进制模式，数量过于庞大了。所以，我们想到了一种特殊的方法，来减少一些冗余的LBP模式。</p>
<p>研究者们提出了统一化模式（Uniform Patterns），再次改进了LBP算子的理论。</p>
<p><strong>1. 跳变：</strong></p>
<p>二进制序列中存在从1到0或者0到1的转变，可以称作是一次跳变。下面我们将举例说明跳变次数的计算：</p>
<table>
<thead>
<tr>
<th>二进制序列</th>
<th>跳变次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000000  或  11111111</td>
<td>0次跳变</td>
</tr>
<tr>
<td>01000000  或 00010000</td>
<td>1次跳变</td>
</tr>
<tr>
<td>01010000</td>
<td>4次跳变</td>
</tr>
</tbody>
</table>
<p><strong>2. 统一化模式：</strong></p>
<p>对于一个局部二进制模型而言，在将其二进制位串视为循环的情况下，如果其中包含的从0到1或者从1到0的转变不多于2个，则称为统一化模式。所以上例中的模式“01010000”就不属于统一化模式。</p>
<p><strong>3. 混合模式：</strong></p>
<p>序列中包含的跳变为2次以上的，可以称为混合模式。</p>
<h4 id="统一化的意义"><a class="markdownIt-Anchor" href="#统一化的意义"></a> 统一化的意义</h4>
<p>在随后的LBP直方图的计算过程中，只<strong>为统一化模式分配单独的直方图收集箱，而所有的非统一化模式都被放入一个公用收集箱中</strong>，使得LBP特征的数目大大减少。</p>
<p>一般来说，保留的统一化的模式往往是反映重要信息的那些模式，而那些非统一化模式中过多的转变往往由噪声引起，没有良好的统计意义。</p>
<p>假设图像分块区域大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn><mo>×</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">18 \times 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>，则像素的总数为360个。如果采用8邻域像素的标准LBP算子，收集箱（特征）数目为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>256</mn></mrow><annotation encoding="application/x-tex">2^8 = 256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">6</span></span></span></span>个，平均到每个收集箱的像素数目还不到2个。但是在统一化LBP算子的收集箱数目为59个（58个统一化模式收集箱加上1个非统一化模式收集箱），平均每个收集箱中将含有6个左右的像素点，因此更具有统计意义。</p>
<h4 id="收集箱个数计算"><a class="markdownIt-Anchor" href="#收集箱个数计算"></a> 收集箱个数计算</h4>
<p>将模式进行统一化后，实现了模式数量的降维，从之前的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup></mrow><annotation encoding="application/x-tex">2^p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span></span></span></span></span></span></span></span>转换成为了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">p * (p - 1) + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>。笔者翻看了很多博客，并没有详细的说明最后的维度是怎么计算的，也就是我们收集箱的个数计算。那么这节我们就来讨论一下。</p>
<p>接下来对8位二进制序列下的收集箱个数进行计算：</p>
<p><strong>1. 0个转变（2个）：</strong></p>
<p>11111111，00000000。</p>
<p>**2. 1个转变（7 x 2 = 14）： **01111111，00111111，00011111，00001111，00000111，00000011，00000001。</p>
<p><strong>3. 2个转变（42）</strong>：</p>
<ul>
<li><strong>6 x 2</strong>：01000000，00100000，00010000，00001000，00000100，00000010</li>
<li><strong>5 x 2</strong>：01100000，00110000，00011000，00001100，00000110</li>
<li><strong>4 x 2</strong>：01110000，00111000，00011100，00001110</li>
<li><strong>3 x 2</strong>：01111000，00111100，00011110</li>
<li><strong>2 x 2</strong>：01111100，00111110</li>
<li><strong>1 x 2</strong>：01111110</li>
</ul>
<p>值得注意的是，上面的“ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">K \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> ”中的2表示有两种情况，即反码和原码两种，这样便得到了58种统一化的编码，比原来的256种减少了很多。</p>
<p>总结一下，经过上面的计算知道，这种统一化后的编码个数可以用公式（4）表示。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>P</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>P</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">T = P * (P - 1) + 2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p>
<h3 id="opencv实现人脸检测"><a class="markdownIt-Anchor" href="#opencv实现人脸检测"></a> openCV实现人脸检测</h3>
<h4 id="读取图片"><a class="markdownIt-Anchor" href="#读取图片"></a> 读取图片</h4>
<p>这次仍然是把待读取的照片放入img包中，图片名为cv_3.jpeg。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">filepath = <span class="string">&quot;../img/cv_3.jpeg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片，路径不能含有中文名，否则图片读取不出来</span></span><br><span class="line">image = cv2.imread(filepath)</span><br><span class="line"><span class="comment"># 显示图片</span></span><br><span class="line">plt.imshow(<span class="string">&#x27;image&#x27;</span>, image)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这次的待检测图片：</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626165645531-1496269276.png" style = "width: 60%">
<h4 id="加载级联文件"><a class="markdownIt-Anchor" href="#加载级联文件"></a> 加载级联文件</h4>
<p>我在这个地方是报错了的，据说需要使用绝对路径，但是队里的其他人都不是像我这么玩的… 有点奇怪～</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要是Anaconda虚拟环境下的绝对路径</span></span><br><span class="line">cascade_path = <span class="string">&quot;/Users/sonata/opt/anaconda3/share/opencv4/lbpcascades/lbpcascade_frontalface_improved.xml&quot;</span>  </span><br><span class="line"><span class="comment"># 下载到了本地使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载人脸级联文件</span></span><br><span class="line">faceCascade = cv2.CascadeClassifier(cascade_path)</span><br></pre></td></tr></table></figure>
<h4 id="人脸检测"><a class="markdownIt-Anchor" href="#人脸检测"></a> 人脸检测</h4>
<p>OpenCV给我们使用特征数据的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectMultiScale</span>(<span class="params">self, image, scaleFactor=None, minNeighbors=None, flags=None, minSize=None, maxSize=None</span>)</span></span><br><span class="line"><span class="function"><span class="title">params</span>:</span></span><br><span class="line">  <span class="number">1.</span> scaleFactor: 指定每个图像比例缩小多少图像</span><br><span class="line">  <span class="number">2.</span> minNeighbors: 指定每个候选矩形必须保留多少个邻居，值越大说明精度要求越高</span><br><span class="line">  <span class="number">3.</span> minSize：检测到的最小矩形大小</span><br><span class="line">  <span class="number">4.</span> maxSize: 检测到的最大矩形大小</span><br></pre></td></tr></table></figure>
<p>所以我们使用此方法检测图片中的人脸</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度转换</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸检测</span></span><br><span class="line">faces = faceCascade.detectMultiScale(gray, <span class="number">1.1</span>, <span class="number">2</span>, minSize=(<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line">print(faces)  <span class="comment"># 识别的人脸信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环处理每一张脸</span></span><br><span class="line"><span class="keyword">for</span> x, y, w, h <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(img, pt1=(x, y), pt2=(x+w, y+h), color=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>], thickness=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>得到检测结果如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626165822925-1168103124.png" alt="" /></p>
<h4 id="处理脏数据"><a class="markdownIt-Anchor" href="#处理脏数据"></a> 处理脏数据</h4>
<p>我们发现除了检测到人脸数据，还有一些其他的脏数据，这个时候可以打印检测出的人脸数据位置和大小结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">306</span>  <span class="number">357</span>  <span class="number">177</span>  <span class="number">177</span>]</span><br><span class="line"> [<span class="number">1264</span>  <span class="number">410</span>  <span class="number">116</span>  <span class="number">116</span>]</span><br><span class="line"> [ <span class="number">656</span>  <span class="number">378</span>  <span class="number">241</span>  <span class="number">241</span>]</span><br><span class="line"> [<span class="number">1049</span>  <span class="number">376</span>  <span class="number">243</span>  <span class="number">243</span>]]</span><br></pre></td></tr></table></figure>
<p>从大小中我们看到最大的两个矩形，刚好是人脸数据，其余都是脏数据，那么继续修改函数参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">faces = faceCascade.detectMultiScale(gray, <span class="number">1.1</span>, <span class="number">2</span>, minSize=(<span class="number">150</span>, <span class="number">150</span>))</span><br><span class="line"><span class="comment"># 把最小矩形大小改成150</span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以把脏数据给除去了：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200626165843711-83738600.png" alt="" /></p>
<h3 id="c实现人脸检测"><a class="markdownIt-Anchor" href="#c实现人脸检测"></a> C++实现人脸检测</h3>
<h4 id="原始lbp算子"><a class="markdownIt-Anchor" href="#原始lbp算子"></a> 原始LBP算子</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始LBP算子只是计算8邻域内的局部二值模式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">static</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">olbp_</span><span class="params">(InputArray _src, OutputArray _dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// get matrices</span></span><br><span class="line">    Mat src = _src.getMat();</span><br><span class="line">    <span class="comment">// allocate memory for result</span></span><br><span class="line">    _dst.create(src.rows<span class="number">-2</span>, src.cols<span class="number">-2</span>, CV_8UC1);</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line">    <span class="comment">// zero the result matrix</span></span><br><span class="line">    dst.setTo(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// calculate patterns</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;src.rows<span class="number">-1</span>;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;src.cols<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            _Tp center = src.at&lt;_Tp&gt;(i,j);</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> code = <span class="number">0</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i<span class="number">-1</span>,j<span class="number">-1</span>) &gt;= center) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i<span class="number">-1</span>,j) &gt;= center) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i<span class="number">-1</span>,j+<span class="number">1</span>) &gt;= center) &lt;&lt; <span class="number">5</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i,j+<span class="number">1</span>) &gt;= center) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i+<span class="number">1</span>,j+<span class="number">1</span>) &gt;= center) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i+<span class="number">1</span>,j) &gt;= center) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i+<span class="number">1</span>,j<span class="number">-1</span>) &gt;= center) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            code |= (src.at&lt;_Tp&gt;(i,j<span class="number">-1</span>) &gt;= center) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            dst.at&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(i<span class="number">-1</span>,j<span class="number">-1</span>) = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部接口，根据不同的数据类型调用模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cv::olbp</span><span class="params">(InputArray src, OutputArray dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (src.getMat().type()) &#123;</span><br><span class="line">    <span class="keyword">case</span> CV_8SC1:   olbp_&lt;<span class="keyword">char</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC1:   olbp_&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16SC1:  olbp_&lt;<span class="keyword">short</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16UC1:  olbp_&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32SC1:  olbp_&lt;<span class="keyword">int</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32FC1:  olbp_&lt;<span class="keyword">float</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_64FC1:  olbp_&lt;<span class="keyword">double</span>&gt;(src,dst); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="built_in">string</span> error_msg = format(<span class="string">&quot;Using Original Local Binary Patterns for feature extraction only works                                     </span></span><br><span class="line"><span class="string">        on single-channel images (given %d). Please pass the image data as a grayscale image!&quot;</span>, type);</span><br><span class="line">        CV_Error(CV_StsNotImplemented, error_msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">cv::olbp</span><span class="params">(InputArray src)</span> </span>&#123;</span><br><span class="line">    Mat dst;</span><br><span class="line">    olbp(src, dst);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="圆形lbp算子"><a class="markdownIt-Anchor" href="#圆形lbp算子"></a> 圆形LBP算子</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src为输入图像，dst为输出图像，radius为半径，neighbor为计算当前点LBP所需的邻域像素点数，也就是样本点个数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">static</span> <span class="comment">// 模板函数，根据不同的原始数据类型得到不同的结果</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">elbp_</span><span class="params">(InputArray _src, OutputArray _dst, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//get matrices</span></span><br><span class="line">    Mat src = _src.getMat();</span><br><span class="line">    <span class="comment">// allocate memory for result因此不用在外部给_dst分配内存空间，输出数据类型都是int</span></span><br><span class="line">    _dst.create(src.rows<span class="number">-2</span>*radius, src.cols<span class="number">-2</span>*radius, CV_32SC1);</span><br><span class="line">    Mat dst = _dst.getMat();</span><br><span class="line">    <span class="comment">// zero</span></span><br><span class="line">    dst.setTo(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;neighbors; n++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sample points 获取当前采样点</span></span><br><span class="line">        <span class="keyword">float</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(-radius) * <span class="built_in">sin</span>(<span class="number">2.0</span>*CV_PI*n/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(neighbors));</span><br><span class="line">        <span class="keyword">float</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(radius) * <span class="built_in">cos</span>(<span class="number">2.0</span>*CV_PI*n/<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(neighbors));</span><br><span class="line">        <span class="comment">// relative indices 下取整和上取整</span></span><br><span class="line">        <span class="keyword">int</span> fx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(x)); <span class="comment">// 向下取整</span></span><br><span class="line">        <span class="keyword">int</span> fy = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(y));</span><br><span class="line">        <span class="keyword">int</span> cx = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">ceil</span>(x));  <span class="comment">// 向上取整</span></span><br><span class="line">        <span class="keyword">int</span> cy = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">ceil</span>(y));</span><br><span class="line">        <span class="comment">// fractional part 小数部分</span></span><br><span class="line">        <span class="keyword">float</span> tx = x - fx;</span><br><span class="line">        <span class="keyword">float</span> ty = y - fy;</span><br><span class="line">        <span class="comment">// set interpolation weights 设置四个点的插值权重</span></span><br><span class="line">        <span class="keyword">float</span> w1 = (<span class="number">1</span> - tx) * (<span class="number">1</span> - ty);</span><br><span class="line">        <span class="keyword">float</span> w2 =      tx  * (<span class="number">1</span> - ty);</span><br><span class="line">        <span class="keyword">float</span> w3 = (<span class="number">1</span> - tx) *      ty;</span><br><span class="line">        <span class="keyword">float</span> w4 =      tx  *      ty;</span><br><span class="line">        <span class="comment">// iterate through your data 循环处理图像数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=radius; i &lt; src.rows-radius;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=radius;j &lt; src.cols-radius;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// calculate interpolated value 计算插值，t表示四个点的权重和</span></span><br><span class="line">                <span class="keyword">float</span> t = w1*src.at&lt;_Tp&gt;(i+fy,j+fx) + </span><br><span class="line">w2*src.at&lt;_Tp&gt;(i+fy,j+cx) + </span><br><span class="line">w3*src.at&lt;_Tp&gt;(i+cy,j+fx) + </span><br><span class="line">w4*src.at&lt;_Tp&gt;(i+cy,j+cx);</span><br><span class="line">                <span class="comment">// floating point precision, so check some machine-dependent epsilon</span></span><br><span class="line">                <span class="comment">// std::numeric_limits&lt;float&gt;::epsilon()=1.192092896e-07F</span></span><br><span class="line">                <span class="comment">// 当t&gt;=src(i,j)的时候取1，并进行相应的移位</span></span><br><span class="line">                dst.at&lt;<span class="keyword">int</span>&gt;(i-radius,j-radius) += ((t &gt; src.at&lt;_Tp&gt;(i,j)) || </span><br><span class="line">                            (<span class="built_in">std</span>::<span class="built_in">abs</span>(t-src.at&lt;_Tp&gt;(i,j)) &lt; <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">float</span>&gt;::epsilon())) &lt;&lt; n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部接口，根据不同的数据类型调用模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">elbp</span><span class="params">(InputArray src, OutputArray dst, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = src.type();</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CV_8SC1:   elbp_&lt;<span class="keyword">char</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_8UC1:   elbp_&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(src, dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16SC1:  elbp_&lt;<span class="keyword">short</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_16UC1:  elbp_&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32SC1:  elbp_&lt;<span class="keyword">int</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_32FC1:  elbp_&lt;<span class="keyword">float</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CV_64FC1:  elbp_&lt;<span class="keyword">double</span>&gt;(src,dst, radius, neighbors); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">string</span> error_msg = format(<span class="string">&quot;Using Circle Local Binary Patterns for feature extraction only works                                    </span></span><br><span class="line"><span class="string">         on single-channel images (given %d). Please pass the image data as a grayscale image!&quot;</span>, type);</span><br><span class="line">        CV_Error(CV_StsNotImplemented, error_msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">cv::elbp</span><span class="params">(InputArray src, <span class="keyword">int</span> radius, <span class="keyword">int</span> neighbors)</span> </span>&#123;</span><br><span class="line">    Mat dst;</span><br><span class="line">    elbp(src, dst, radius, neighbors);</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>在这一节的学习中，比较困扰我的是LBP算子它对于人脸检测过程中的用处，以及优化后的LBP算子是如何进行特征降维的，它的计算过程是什么。不过总算都是搞清楚了，也花了很多时间去理解，希望依旧能评个优秀～</p>
<h3 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h3>
<p>《数字图像处理与python实现》</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/saw009/article/details/80105871">https://blog.csdn.net/saw009/article/details/80105871</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zouxy09/article/details/7929531">https://blog.csdn.net/zouxy09/article/details/7929531</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dujian996099665/article/details/8886576">https://blog.csdn.net/dujian996099665/article/details/8886576</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:sonatau@163.com">Sonata</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91LBP%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/">http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91LBP%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yluy.gitee.io" target="_blank">私人海域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%AD%E7%AD%89/">中等</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bffpptgj318g0o20xd.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><img class="prev-cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bhy9x1bj31500jgtg9.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【图像处理】Haar特征描述算子</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Harris%E7%89%B9%E5%BE%81%E7%82%B9%E6%A3%80%E6%B5%8B/"><img class="next-cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bbz5079j31hc0u0qfo.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【图像处理】Harris特征点检测</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/04/21/Sketch-Simplification线稿简化/" title="Sketch_Simplification线稿简化"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008i3skNly1gpsvjxm2vcj31900u01kz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-21</div><div class="relatedPosts_title">Sketch_Simplification线稿简化</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/16/Attention机制在图像处理中的应用/" title="Attention机制在图像处理中的应用"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gpldjeoh5dj31400u0e83.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-16</div><div class="relatedPosts_title">Attention机制在图像处理中的应用</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/20/Trapped-Ball-Segmentation陷球分割/" title="Trapped-Ball-Segmentation陷球分割"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqikhejn7j31960u0qv6.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="relatedPosts_title">Trapped-Ball-Segmentation陷球分割</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/24/【图像处理】Harris特征点检测/" title="【图像处理】Harris特征点检测"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bbz5079j31hc0u0qfo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="relatedPosts_title">【图像处理】Harris特征点检测</div></div></a></div><div class="relatedPosts_item"><a href="/2020/10/09/【机器学习】AdaBoost原理/" title="【机器学习】AdaBoost原理"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjiurm5zzgj30rs0ijwhx.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-09</div><div class="relatedPosts_title">【机器学习】AdaBoost原理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/03/【机器学习】决策树算法原理与实践/" title="【机器学习】决策树算法原理与实践"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gictu4nwqdj30jg0czwfe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-03</div><div class="relatedPosts_title">【机器学习】决策树算法原理与实践</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bffpptgj318g0o20xd.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Sonata</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">hi there ~</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>