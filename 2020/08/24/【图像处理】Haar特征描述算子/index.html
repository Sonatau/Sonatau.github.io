<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【图像处理】Haar特征描述算子 | 私人海域</title><meta name="description" content="Haar特征描述算子 经过前面的学习，个人对几个基础概念仍然有些模糊，比如说图像特征、级联分类器等，所以这篇笔记就结合这些天查阅到的知识点和Datawhale提供的学习内容一起记录一下，会比较注重概念的理解，文字内容多一些～  图像特征 实际上，计算机是不认识图像的，但倘若我们能够将图像数字化地输入计算机，它就能够理解不同的图像，从而有真正意义上的视觉。所以在进行人脸检测或者识别的过程中，需要关"><meta name="keywords" content="中等"><meta name="author" content="Sonata,sonatau@163.com"><meta name="copyright" content="Sonata"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjtdrp4tj30rs0rsjwe.jpg"><link rel="canonical" href="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="【图像处理】Haar特征描述算子"><meta property="og:url" content="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><meta property="og:site_name" content="私人海域"><meta property="og:description" content="Haar特征描述算子 经过前面的学习，个人对几个基础概念仍然有些模糊，比如说图像特征、级联分类器等，所以这篇笔记就结合这些天查阅到的知识点和Datawhale提供的学习内容一起记录一下，会比较注重概念的理解，文字内容多一些～  图像特征 实际上，计算机是不认识图像的，但倘若我们能够将图像数字化地输入计算机，它就能够理解不同的图像，从而有真正意义上的视觉。所以在进行人脸检测或者识别的过程中，需要关"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bhy9x1bj31500jgtg9.jpg"><meta property="article:published_time" content="2020-08-24T15:26:17.000Z"><meta property="article:modified_time" content="2020-08-24T15:28:16.648Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.2',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-24 23:28:16'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.2"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwjow3dndj30jg0jgdgq.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">22</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90"><span class="toc-number">1.</span> <span class="toc-text"> Haar特征描述算子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text"> 图像特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 基础概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%8F%8A%E5%85%B6%E7%BB%9F%E8%AE%A1%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text"> 直方图及其统计特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text"> 级联分类器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 概念理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#haar%E7%89%B9%E5%BE%81%E5%8F%8A%E5%85%B6%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text"> Haar特征及其级联分类器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 概念与应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#haar%E7%89%B9%E5%BE%81%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.2.</span> <span class="toc-text"> Haar特征的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%AF%E5%88%86%E5%9B%BE"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 积分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#haar%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text"> Haar级联分类器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A7%E8%81%94%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 级联分类器的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#opencv%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text"> openCV实现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 静态检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 动态检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6nms"><span class="toc-number">1.6.</span> <span class="toc-text"> 非极大值抑制（NMS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 公式理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bhy9x1bj31500jgtg9.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">私人海域</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">【图像处理】Haar特征描述算子</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-24T15:26:17.000Z" title="发表于 2020-08-24 23:26:17">2020-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-24T15:28:16.648Z" title="更新于 2020-08-24 23:28:16">2020-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/openCV/">openCV</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="haar特征描述算子"><a class="markdownIt-Anchor" href="#haar特征描述算子"></a> Haar特征描述算子</h2>
<p>经过前面的学习，个人对几个基础概念仍然有些模糊，比如说图像特征、级联分类器等，所以这篇笔记就结合这些天查阅到的知识点和Datawhale提供的学习内容一起记录一下，会比较注重概念的理解，文字内容多一些～</p>
<h3 id="图像特征"><a class="markdownIt-Anchor" href="#图像特征"></a> 图像特征</h3>
<p>实际上，计算机是不认识图像的，但倘若我们能够将图像数字化地输入计算机，它就能够理解不同的图像，从而有真正意义上的视觉。所以在进行人脸检测或者识别的过程中，需要关注的是如何从图像中提取出有用的数据或信息，得到图像的“非图像”的表示或描述，比如常用的数值、向量等。这个过程就是特征提取。而提取出来的特征我们可以通过训练过程教会计算机如何懂得这些特征，从而使得计算机具备识别图像的能力。</p>
<h4 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h4>
<p><strong>特征</strong></p>
<p>严格上说，特征是某一类对象区别于其他类对象的相应特点或特性。对于一幅图像而言，它自身的纹理、亮度等等，都可以成为区别于其他图像的自身特征。当然有些特征需要经过变换处理之后才能得到，需要我们转换成直方图等等。</p>
<p><strong>特征向量</strong></p>
<p>如果现在我们想要表示一个抽象的对象，可以把这个对象的特征们都组合在一起，形成一个特征向量来表示。如果这个物体只有单个特征，那特征向量就是一个一维的向量。如果有n个特征，那对应的，特征向量将是一个n维的。</p>
<p>如下图所示，左图是一些在三维空间中的样本点。假设这些样本是鸢尾花，那么三个坐标轴可能分别代表花瓣的“长度”、“宽度”、“厚度”三个特征，给出三者的分数后，便可在三维空间中详细表示。例如，现在使用一个三维的特征来代表一个植物对象，比如(5,  6.7, 1)。</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630161647000-2034650917.png" style="width:67%">
<p><strong>特征提取原则</strong></p>
<p>其实图像识别是一个分类的过程。我们需要识别出某图像所属的类别，就需要将它和其他不同的图像区分开来。那么这就要求选取的特征不仅要能够很好地描述图像，重要的是还要能够很好地区分不同类别的图像。</p>
<p>我们更希望选择那些在同类图像之间差异较小，但是在不同类别的图像之间差异较大的图像特征作为我们的判断标准，可以称它们为是最有区分能力的特征。</p>
<p>那么重点来了，在特征提取的过程中我们应该注意些什么呢？</p>
<p>如果在分类过程中，仅仅是简单地提取图像中所有像素的灰度值作为特征，虽然可以尽可能地提供信息给分类器，但是高纬度意味着高计算复杂度，在后续的处理和识别中很容易导致维度灾难。</p>
<p>所以，我们仅仅只需要将部分像素信息交给分类器就已经足够了。</p>
<blockquote>
<p>比如说，在表情识别的时候，我们并不需要肤色、面部轮廓等特征，只要给出眉毛、眼睛、和嘴这些表情区域作为特征提取的候选区，就已经完全足够了。</p>
</blockquote>
<p><strong>评价标准</strong></p>
<p>评价标准其实有一定的主观性，但是还是有一些原则是可以普遍遵循的，比如说下面这几点：</p>
<ol>
<li>特征应该容易提取，也就是说在提取的过程中不应该花费过多的代价。</li>
<li>选取的特征应该对噪声、不相关的转换等操作不敏感。</li>
<li>寻找一个最具区分能力的特征。</li>
</ol>
<h3 id="直方图及其统计特征"><a class="markdownIt-Anchor" href="#直方图及其统计特征"></a> 直方图及其统计特征</h3>
<p>其实直方图更多是作为一种辅助图像分析的工具，但它也可以作为图像纹理描述的一种强大手段。</p>
<p>笔者在上一篇博客已经详细阐述了图像纹理的概念及其特点，它具有一定的周期性。我们知道，纹理区域的像素灰度级分布具有一定的形式，而直方图又恰好可以用来描述图像中像素灰度级分布的有力工具，所以我们当然可以使用直方图来描述图像纹理咯～</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630161824054-1900048032.png" style = "width:67%">
<p>那么，毫无疑问的是，相似的纹理具有相似的直方图，也就可以说明，直方图和纹理之间存在一定的对应关系。然后，经过分析可以想象到，直方图本身就是一个向量，而向量的维数是直方图统计的灰度级数，因此我们可以直接把这个直方图形成的向量作为代表图像纹理的样本特征向量，交给分类器处理，就像LBP直方图所做的工作那样。</p>
<p>当然，还有其他思路，比如说从直方图中提取出能够描述自身的统计特征，然后组合成样本的特征向量，这样还可以降低特征向量的维数。</p>
<h3 id="级联分类器"><a class="markdownIt-Anchor" href="#级联分类器"></a> 级联分类器</h3>
<p>在上节的学习过程中，遇到了一个新的名词，叫做级联分类器。我不仅不知道它是个什么东西，还老念错它的名字，所以也找了一些资料，决定搞明白它到底是个啥玩意。</p>
<h4 id="概念理解"><a class="markdownIt-Anchor" href="#概念理解"></a> 概念理解</h4>
<p>通常情况下，分类器需要对多个图像特征进行识别。比如在识别一个动物是狗还是其他动物的时候，可能需要根据多个条件进行判断，如果首先就比较它们有几条腿：</p>
<p>● 有“四条腿”的动物被判断为“可能为狗”，并对此范围内的对象继续进行分析和判断。</p>
<p>● 没有“四条腿”的动物直接被否决，即不可能为狗。</p>
<p>这样，仅仅比较腿的数目，根据这个特征就能排除样本集中大量的负类（例如鸡、鸭、鹅等不是狗的其他动物实例）。</p>
<p>级联分类器就是基于这种思路，将多个简单的分类器按照一定的顺序级联而成的。</p>
<p>它将多个弱分类器串联成了强分类器，其中弱分类器是一些性能受限的分类器，它们无法正确区分所有事物。而强分类器是可以正确地对数据进行分类的。之所以以弱分类器为基础，是因为这种技术可以避免执行高精度的单一分类器所产生的问题。</p>
<p>如果一味强调分类器的精确度，可能会变成计算密集型且运行速度变慢。</p>
<p>级联分类器的基础示意图如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630161905885-1287692645.png"  style = "width: 40% ;">
<h4 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h4>
<p>在开始阶段仅仅进行非常简单的判断，就能够排除明显不符合要求的样本。那些在开始阶段就被排除的负类，之后都不需要参与分类，只有正样本才会送到下一个强分类器进行再次检验，这样就保证了最后输出的正样本的伪正(false positive)的可能性非常低。这样很大程度提高了后面分类的速度，而且每个弱分类器也不需要太精确。</p>
<h3 id="haar特征及其级联分类器"><a class="markdownIt-Anchor" href="#haar特征及其级联分类器"></a> Haar特征及其级联分类器</h3>
<p>Haar特征可以用来反映图像灰度变化，而使用该算子进行人脸识别时，正是从人脸灰度变化角度考虑的。</p>
<h4 id="概念与应用"><a class="markdownIt-Anchor" href="#概念与应用"></a> 概念与应用</h4>
<p>研究者发现，从像素的差值这个角度考虑，两幅看似不相关的图像可能会存在一定的相关性。随后提出的Haar特征正是从这个角度出发，这些特征包含了垂直特征、水平特征和对角特征。根据特征的特点，构建了特征模版，使用某类模版可以判断是否具备某类特征。</p>
<p>Haar算子如今普遍适用于行人检测和人脸检测中。</p>
<h4 id="haar特征的计算"><a class="markdownIt-Anchor" href="#haar特征的计算"></a> Haar特征的计算</h4>
<p>简单的几个Haar特征如下图所示，它主要反映的是<strong>图像的灰度变化</strong>（你品，你细品），它将像素划分为模块后求差值。其中特征模版是用黑白两种矩形框组合成特征模版的。</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630161938835-243399537.png"  style = "width: 40% ;">
<p>在特征模版中，用白色矩形像素块的像素和减去黑色矩形像素块的像素和来表示该模版的特征。那么经过上述处理之后，人脸部的一些特征就可以使用矩形框的差值来简单表示，其中公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi mathvariant="normal">白</mi><mi mathvariant="normal">色</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">像</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">和</mi><mo stretchy="false">)</mo><mo>−</mo><mo>∑</mo><mo stretchy="false">(</mo><mi mathvariant="normal">黑</mi><mi mathvariant="normal">色</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">像</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">和</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T = \sum(白色区域像素和) - \sum(黑色区域像素和)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">(</span><span class="mord cjk_fallback">白</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">像</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">和</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">(</span><span class="mord cjk_fallback">黑</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">像</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">和</span><span class="mclose">)</span></span></span></span></span></p>
<p>之所以可以使用haar算子来识别某些面部特征，是因为在我们的面部构造上存在了一些明显的特点。</p>
<p>比如说眼睛的颜色比脸颊的颜色要深，那么让这两者的区域像素和做减法操作时，其差值就会比较大。但假如我们对两个都是脸颊的区域做这样的操作，显然差值很小，有可能是0。那么这样眼睛区域和非眼睛区域就能够使用差值的大小来进行区分了。</p>
<p>因此，经过分析发现，面部的这些特点使得有很多区域都可以借助<strong>不同的模版</strong>来计算并区分。</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162014953-1976155267.png" style = "width: 40% ;" >
<p>同样的，<strong>我们希望当把矩形放到人脸区域计算出来的特征值和放到非人脸区域计算出来的特征值差别越大越好</strong>，这样我们就能够用来区分人脸和非人脸了。</p>
<p>关于Harr特征中的矩形框，有如下3个变量。</p>
<p>● 矩形位置：矩形框要逐像素地划过（遍历）整个图像获取每个位置的差值。</p>
<p>● 矩形大小：矩形的大小可以根据需要做任意调整。</p>
<p>● 矩形类型：包含垂直、水平、对角等不同类型。</p>
<p>上述3个变量保证了能够细致全面地获取图像的特征信息。</p>
<h4 id="积分图"><a class="markdownIt-Anchor" href="#积分图"></a> 积分图</h4>
<p>前面说到，计算haar特征之前，要先计算两块区域的和，再算它们之间的差。</p>
<p>都说程序员是最知道偷懒的，他们发现光是计算区域和也好累，因为如果我们细致全面地获取图像的特征信息，使用不同的矩形进行特征提取，若同一个像素包含在不同的重叠矩形区域中会被多次遍历，导致计算量加大。</p>
<p>所以学者们又提出了简化Haar特征的方法，也就引出了积分图的计算。假设现在有一张图，如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162035485-263321560.png" style = "width: 40% ;" >
<p>如果需要计算图像中任意矩形区域的大小，不需要遍历区域内的所有像素。</p>
<p>想象下图中左上的点和任何相对的点P形成的矩形。设AP表示这个矩形的面积。如前图所示，AB表示通过取左上角点和相对的B点形成的5×2矩形的面积。为了清楚起见，看一下下图：</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162057764-1714674920.png" style = "width: 40% ;" >
<p>上图中的左上部分，着色像素表示左上角与点A之间的区域。这个区域用AA表示，剩下的图用AB、AC、AD表示。若想计算上图ABCD区域，将使用下列公式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>A</mi><mi>B</mi><mi>C</mi><mi>D</mi></mrow></msub><mo>=</mo><msub><mi>T</mi><mrow><mi>A</mi><mi>C</mi></mrow></msub><mo>−</mo><mo stretchy="false">(</mo><msub><mi>T</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>+</mo><msub><mi>T</mi><mrow><mi>A</mi><mi>D</mi></mrow></msub><mo>−</mo><msub><mi>T</mi><mrow><mi>A</mi><mi>A</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_{ABCD} = T_{AC} - (T_{AB} + T_{AD} - T_{AA})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>这种特定的公式有什么特别的地方吗？</p>
<p>⚠️  实际上我们知道，提取图像的Haar特征需要计算多个尺度矩形的和。而这些计算是重复的，因为反复遍历了同一个像素。那么上面这种方法借助了动态规划的思想，避免了对同一个位置的重复计算，极大地节省了时间开销。</p>
<h4 id="haar级联分类器"><a class="markdownIt-Anchor" href="#haar级联分类器"></a> Haar级联分类器</h4>
<p>这下总算能具体说说Haar级联分类器到底是什么，应该怎么使用的了！！其实这部分的内容，助教给的学习资料已经很清楚了，甚至很多图像处理的书都没他讲的明白。。</p>
<p>简单地说，在进行人脸检测的过程中，需要使用一个强分类器，且其由多个弱分类器组成。那么其中的每个弱分类器都只包含一个Haar特征。每个分类器都将确定一个阈值，如果某区域的处理差值小于该阈值，则被归为负类，反之则进行下一级的弱分类，最终经过多个弱分类器后，可完成检测。其分类过程如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162122207-262929721.png" style = "width: 40% ;">
<p>那么接下来，再具体地说明执行过程：</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162145283-1233495463.png"  style = "width: 60% ;">
<ol>
<li>首先，对于一幅图像，它可能存在K个面部特征，假设这些面部特征可以用来区分眼睛、眉毛、鼻子、嘴等特征。</li>
<li>确定一些超参数，如滑动窗口的大小，及窗口的移动步长。窗口从上往下，从左向右地滑动。在滑动的过程中，每次都可以计算出一个数值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>。</li>
<li>滑动结束时，将得到的特征值进行排序，并选取一个最佳特征值（最优阈值），使得在该特征值下，对于该特征而言，样本的加权错误率最低。这样就训练出了一个弱分类器。</li>
<li>因为面部特征的不同，我们将采用不同的滑动窗口进行特征提取。所以根据不同的窗口识别不同的特征，进而训练出了不同的弱分类器。</li>
<li>对于每个弱分类器都将计算它的错误率，选择错误率最低的K个弱分类器，组合成强分类器。</li>
<li>一组样本投入强分类器后，在每个渐进的阶段，分类器逐渐在较少的图像窗口上使用更多的特征（负类被丢弃）。如果某个矩形区域在所有弱分类器中都被归结为正类，那么可以认为该区域是存在人脸的。</li>
</ol>
<p>其中，弱分类器训练的具体步骤如下：</p>
<p>1、对于每个特征 𝑓，计算所有训练样本的特征值，并将其排序：</p>
<p>2、扫描一遍排好序的特征值，对排好序的表中的每个元素，计算下面四个值：</p>
<p>计算全部正例的权重和𝑇+；</p>
<p>计算全部负例的权重和𝑇−；</p>
<p>计算该元素前之前的正例的权重和𝑆+；</p>
<p>计算该元素前之前的负例的权重和𝑆−；</p>
<p>3、选取当前元素的特征值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{k,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和它前面的一个特征值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_{k,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间的数作为阈值，所得到的弱分类器就在当前元素处把样本分开 —— 也就是说这个阈值对应的弱分类器将当前元素前的所有元素分为人脸（或非人脸），而把当前元素后（含）的所有元素分为非人脸（或人脸）。该阈值的分类误差为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msup><mi>S</mi><mo>+</mo></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mi>T</mi><mo>−</mo></msup><mo>−</mo><msup><mi>S</mi><mo>−</mo></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>S</mi><mo>−</mo></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mi>T</mi><mo>+</mo></msup><mo>−</mo><msup><mi>S</mi><mo>+</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e=min(S^++(T^--S^-),S^-+(T^+-S^+))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>于是，通过把这个排序表从头到尾扫描一遍就可以为弱分类器选择使分类误差最小的阈值（最优阈值），也就是选取了一个最佳弱分类器。</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162214927-2003490753.png" style = "width: 40% ;">
<h4 id="级联分类器的使用"><a class="markdownIt-Anchor" href="#级联分类器的使用"></a> 级联分类器的使用</h4>
<p>在OpenCV中，有一些训练好的级联分类器供用户使用。这些分类器可以用来检测人脸、脸部特征（眼睛、鼻子）、人类和其他物体。这些级联分类器以XML文件的形式存放在OpenCV源文件的data目录下，加载不同级联分类器的XML文件就可以实现对不同对象的检测。</p>
<p>OpenCV自带的级联分类器存储在OpenCV根文件夹的data文件夹下。该文件夹包含三个子文件夹：haarcascades、hogcascades、lbpcascades，里面分别存储的是Harr级联分类器、HOG级联分类器、LBP级联分类器。</p>
<p>其中，Harr级联分类器多达20多种（随着版本更新还会继续增加），提供了对多种对象的检测功能。部分级联分类器如下表所示：</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162241116-963472225.png" style = "width: 40% ;">
<h3 id="opencv实现过程"><a class="markdownIt-Anchor" href="#opencv实现过程"></a> openCV实现过程</h3>
<h4 id="静态检测"><a class="markdownIt-Anchor" href="#静态检测"></a> 静态检测</h4>
<p>第一步仍然是导入环境包，图片读取，灰度转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filepath = <span class="string">&#x27;../img/cv_2.jpeg&#x27;</span></span><br><span class="line">cascadepath = <span class="string">&#x27;/Users/sonata/opt/anaconda3/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&#x27;</span></span><br><span class="line"></span><br><span class="line">img = cv.imread(filepath)</span><br><span class="line">grey = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>
<p>随后加载haar的级联分类器，并且使用<code>detectMultiScale()</code>函数来处理灰度图，并用矩形框将人脸框出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">faceCascade = cv.CascadeClassifier(cascadepath)</span><br><span class="line">faces = faceCascade.detectMultiScale(grey, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">    img = cv.rectangle(img, (x, y), (x+w, y+h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&#x27;FaceDetected&#x27;</span>, img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>得到最终的检测结果如下图所示，效果比LBP好一些似乎，因为上次也是这张图，结果就是检测不全。</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162333880-80796421.png" style = "width: 40% ;" >
<p>单独使用了一下眼睛检测，一定是我牙不够白…</p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162351426-1630642234.png" style = "width: 40% ;">
<h4 id="动态检测"><a class="markdownIt-Anchor" href="#动态检测"></a> 动态检测</h4>
<p>接下来就是使用摄像头进行动态检测的过程了。<code>DynamicDetect</code>函数主要包括：打开摄像头、读取帧、检测人脸、扫描检测到的人脸中的眼睛，并使用不同颜色绘制出矩形框。这次助教写的函数解释很清楚，贴出来记录一下重点：</p>
<p>detectMultiScale有许多可选参数；眼睛是一个比较小的人脸特征，并且胡子或者鼻子的本身阴影以及帧的随机阴影都会产生假阳性。通过限制对眼睛搜索的最小尺寸为40x40像素，可以去掉假阳性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detectMultiScale(image, scaleFactor, minNeighbors, flags, minSize, maxSize)</span><br></pre></td></tr></table></figure>
<ul>
<li>scaleFactor：为每一个图像尺度中的尺度参数，默认值为1.1。scaleFactor参数可以决定两个不同大小的窗口扫描之间有多大的跳跃，这个参数设置的大，则意味着计算会变快，但如果窗口错过了某个大小的人脸，则可能丢失物体。</li>
<li>minNeighbors：参数为每一个级联矩形应该保留的邻近个数，默认为3。minNeighbors控制着误检测，默认值为3表明至少有3次重叠检测，我们才认为人脸确实存。</li>
</ul>
<p>个人的实现过程如下，基本上和助教给的差不多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PathOfFaceCascade = <span class="string">&#x27;/Users/sonata/opt/anaconda3/share/opencv4/haarcascades/haarcascade_frontalface_default.xml&#x27;</span></span><br><span class="line">PathOfEyeCascade = <span class="string">&#x27;/Users/sonata/opt/anaconda3/share/opencv4/haarcascades/haarcascade_eye.xml&#x27;</span></span><br><span class="line"></span><br><span class="line">faceCascade = cv.CascadeClassifier(PathOfFaceCascade)</span><br><span class="line">eyeCascade = cv.CascadeClassifier(PathOfEyeCascade)</span><br><span class="line"></span><br><span class="line">camera = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;Dynamic&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = camera.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        grey = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">        faces = faceCascade.detectMultiScale(grey, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            cv.rectangle(frame, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            roi_gray = grey[y:y+h, x:x+w]</span><br><span class="line">            eyes = eyeCascade.detectMultiScale(roi_gray, <span class="number">1.03</span>, <span class="number">5</span>, <span class="number">0</span>, (<span class="number">40</span>, <span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ex, ey, ew, eh) <span class="keyword">in</span> eyes:</span><br><span class="line">                cv.rectangle(frame, (x + ex, ey + y), (ex + x + ew, y + ey + eh), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;Dynamic&#x27;</span>, frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cv.waitKey(<span class="number">100</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">camera.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="非极大值抑制nms"><a class="markdownIt-Anchor" href="#非极大值抑制nms"></a> 非极大值抑制（NMS）</h3>
<p>不知道各位小伙伴有没有想到，一张脸可能会被不同形状的候选矩形框检测出，那么最后将决定以哪个框为我们的最终结果呢？这就需要使用到NMS（Non-Maximum Suppression）方法来去除多余的框。</p>
<img src = "https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162413956-1660898761.png" style = "width: 40% ;">
<h4 id="公式理解"><a class="markdownIt-Anchor" href="#公式理解"></a> 公式理解</h4>
<ol>
<li>首先对所有检测出来的框，根据分数从高到低进行排序。</li>
<li>从分数最高的框开始，计算与分数比自身地的框的IOU，如果IOU大于一定的阈值，就把分数较低的那个去掉。</li>
<li>便利剩余未被去掉的框，重复步骤2的操作。</li>
<li>最后得到一组得分较高且不重复的框。</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>O</mi><mi>U</mi><mo>=</mo><mfrac><mrow><mi>A</mi><mo>⋂</mo><mi>B</mi></mrow><mrow><mi>A</mi><mo>⋃</mo><mi>B</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi mathvariant="normal">重</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">积</mi></mrow><mrow><mi>A</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">积</mi><mo>+</mo><mi>B</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">积</mi><mo>−</mo><mi mathvariant="normal">重</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">积</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">IOU = \frac{A \bigcap B}{A \bigcup B} = \frac{重合面积}{A面积 + B面积 -重合面积}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.36301em;vertical-align:-0.93601em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93601em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4463300000000001em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">积</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">积</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">积</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">积</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<img src= "/img/loading.gif" data-lazy-src="https://img2020.cnblogs.com/blog/1813159/202006/1813159-20200630162439161-1477674097.png" style = "width: 40% ;" >
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ol>
<li>分类任务中可借助图像特征和直方图来完成。</li>
<li>级联分类器有强弱之分，多个弱分类器组成了强分类器。Haar特征就是一种弱分类器。</li>
<li>Haar特征值等于白色矩形像素块的像素和减去黑色矩形像素块的像素和。</li>
<li>人脸包含的每个特征都可以训练出一个弱分类器，选择出K个最优分类器进行组合成为强分类器。</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:sonatau@163.com">Sonata</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/">http://yluy.gitee.io/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91Haar%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yluy.gitee.io" target="_blank">私人海域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%AD%E7%AD%89/">中等</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bhy9x1bj31500jgtg9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91HOG%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><img class="prev-cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bkkp32fj318g0p0qjz.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【图像处理】HOG特征描述算子</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/24/%E3%80%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E3%80%91LBP%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0%E7%AE%97%E5%AD%90/"><img class="next-cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bffpptgj318g0o20xd.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【图像处理】LBP特征描述算子</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/04/21/Sketch-Simplification线稿简化/" title="Sketch_Simplification线稿简化"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008i3skNly1gpsvjxm2vcj31900u01kz.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-21</div><div class="relatedPosts_title">Sketch_Simplification线稿简化</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/16/Attention机制在图像处理中的应用/" title="Attention机制在图像处理中的应用"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gpldjeoh5dj31400u0e83.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-16</div><div class="relatedPosts_title">Attention机制在图像处理中的应用</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/20/Trapped-Ball-Segmentation陷球分割/" title="Trapped-Ball-Segmentation陷球分割"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gpqikhejn7j31960u0qv6.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="relatedPosts_title">Trapped-Ball-Segmentation陷球分割</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/24/【图像处理】Harris特征点检测/" title="【图像处理】Harris特征点检测"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bbz5079j31hc0u0qfo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-24</div><div class="relatedPosts_title">【图像处理】Harris特征点检测</div></div></a></div><div class="relatedPosts_item"><a href="/2020/10/09/【机器学习】AdaBoost原理/" title="【机器学习】AdaBoost原理"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjiurm5zzgj30rs0ijwhx.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-09</div><div class="relatedPosts_title">【机器学习】AdaBoost原理</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/03/【机器学习】决策树算法原理与实践/" title="【机器学习】决策树算法原理与实践"><img class="relatedPosts_cover" data-lazy-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gictu4nwqdj30jg0czwfe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-03</div><div class="relatedPosts_title">【机器学习】决策树算法原理与实践</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gi2bhy9x1bj31500jgtg9.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Sonata</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">hi there ~</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/click_heart.js" async="async"></script></div></body></html>